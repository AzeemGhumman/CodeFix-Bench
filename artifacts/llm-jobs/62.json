{
    "pr": "psf/requests/4718",
    "problem": "Should Authorization header be cleared in https -> http redirect?\nThis may be considered intentional behaviour (in which case feel free to close this), but if a request is made to an https endpoint with authorization and it redirects to http on the same host, the Authorization header is not stripped and will be exposed on the wire.\r\n\r\n## Expected Result\r\n\r\nrebuild_auth would strip the Authorization header if the scheme is changed from https to http.\r\n\r\n## Actual Result\r\n\r\nThe credentials that were intended to be sent over TLS were transmitted in plaintext with the redirected request.\r\n\r\n## Reproduction Steps\r\n\r\nRun an HTTPS server on localhost:4443 that replies with a 302 redirect to `http://localhost:8000`, and a plain HTTP server (or netcat) on localhost:8000. Then run\r\n```python\r\nimport requests\r\nrequests.get('https://localhost:4443', auth=('hello', 'world'), verify=False)\r\n```\r\nThe basic auth credentials are sent in plaintext to `http://localhost:8000` (the `verify=False` is just because I had a self-signed cert).\r\n\r\nHere's the code I used for the SSL server:\r\n```python\r\nimport BaseHTTPServer\r\nimport ssl\r\n\r\nclass Handler(BaseHTTPServer.BaseHTTPRequestHandler):\r\n    def do_GET(self):\r\n        self.send_response(302)\r\n        self.send_header('Location', 'http://localhost:8000/')\r\n        self.end_headers()\r\n        self.wfile.write('')\r\n\r\nhttpd = BaseHTTPServer.HTTPServer(('localhost', 4443), Handler)\r\nhttpd.socket = ssl.wrap_socket (httpd.socket, server_side=True,\r\n                                certfile='yourpemfile.pem')\r\nhttpd.serve_forever()\r\n```\r\n\r\n## System Information\r\n\r\n```\r\n{\r\n  \"chardet\": {\r\n    \"version\": \"3.0.4\"\r\n  }, \r\n  \"cryptography\": {\r\n    \"version\": \"2.2.2\"\r\n  }, \r\n  \"idna\": {\r\n    \"version\": \"2.7\"\r\n  }, \r\n  \"implementation\": {\r\n    \"name\": \"CPython\", \r\n    \"version\": \"2.7.12\"\r\n  }, \r\n  \"platform\": {\r\n    \"release\": \"4.15.0-23-generic\", \r\n    \"system\": \"Linux\"\r\n  }, \r\n  \"pyOpenSSL\": {\r\n    \"openssl_version\": \"1010008f\", \r\n    \"version\": \"18.0.0\"\r\n  }, \r\n  \"requests\": {\r\n    \"version\": \"2.19.1\"\r\n  }, \r\n  \"system_ssl\": {\r\n    \"version\": \"1000207f\"\r\n  }, \r\n  \"urllib3\": {\r\n    \"version\": \"1.23\"\r\n  }, \r\n  \"using_pyopenssl\": true\r\n}\r\n```\n",
    "hint": "From what I can tell by experiment, Firefox and Chromium treat http and https versions of a site as separate authentication realms, and don't automatically reuse basic credentials on either a redirect or manual browsing between the two. Two http URLs with the same host (localhost) and different port numbers also seem to be treated as independent realms.\nFound something about it in [RFC 7235, section 2.2](https://tools.ietf.org/html/rfc7235#section-2.2).\r\n> A protection space is defined by the canonical root URI (the scheme and authority components of the effective request URI; see Section 5.5 of [RFC7230]) of the server being accessed, in combination with the realm value if present.\r\n\r\nwhich suggests that both the scheme and port number should be considered (and in theory one should also check the realm, but that doesn't really fit into request's model that basic credentials are supplied unconditionally rather than in response to WWW-Authentication).",
    "base": "dd754d13de250a6af8a68a6a83a8b4419fd429c6",
    "section": 0,
    "files": [
        "setup.py:PyTest.initialize_options,PyTest.finalize_options,PyTest.run_tests",
        "requests/utils.py:dict_to_sequence,super_len,get_netrc_auth,guess_filename,extract_zipped_paths,from_key_val_list,to_key_val_list,parse_list_header,parse_dict_header,unquote_header_value,dict_from_cookiejar,add_dict_to_cookiejar,get_encodings_from_content,_parse_content_type_header,get_encoding_from_headers,stream_decode_response_unicode,iter_slices,get_unicode_from_response,unquote_unreserved,requote_uri,address_in_network,dotted_netmask,is_ipv4_address,is_valid_cidr,set_environ,should_bypass_proxies,get_environ_proxies,select_proxy,default_user_agent,default_headers,parse_header_links,guess_json_utf,prepend_scheme_if_needed,get_auth_from_url,check_header_validity,urldefragauth,rewind_body,proxy_bypass_registry,proxy_bypass",
        "requests/sessions.py:merge_setting,merge_hooks,SessionRedirectMixin.get_redirect_target,SessionRedirectMixin.resolve_redirects,SessionRedirectMixin.rebuild_auth,SessionRedirectMixin.rebuild_proxies,SessionRedirectMixin.rebuild_method,Session.__init__,Session.__enter__,Session.__exit__,Session.prepare_request,Session.request,Session.get,Session.options,Session.head,Session.post,Session.put,Session.patch,Session.delete,Session.send,Session.merge_environment_settings,Session.get_adapter,Session.close,Session.mount,Session.__getstate__,Session.__setstate__,session",
        "requests/__init__.py:check_compatibility,_check_cryptography,NullHandler.emit",
        "requests/models.py:RequestEncodingMixin.path_url,RequestEncodingMixin._encode_params,RequestEncodingMixin._encode_files,RequestHooksMixin.register_hook,RequestHooksMixin.deregister_hook,Request.__init__,Request.__repr__,Request.prepare,PreparedRequest.__init__,PreparedRequest.prepare,PreparedRequest.__repr__,PreparedRequest.copy,PreparedRequest.prepare_method,PreparedRequest._get_idna_encoded_host,PreparedRequest.prepare_url,PreparedRequest.prepare_headers,PreparedRequest.prepare_body,PreparedRequest.prepare_content_length,PreparedRequest.prepare_auth,PreparedRequest.prepare_cookies,PreparedRequest.prepare_hooks,Response.__init__,Response.__enter__,Response.__exit__,Response.__getstate__,Response.__setstate__,Response.__repr__,Response.__bool__,Response.__nonzero__,Response.__iter__,Response.ok,Response.is_redirect,Response.is_permanent_redirect,Response.next,Response.apparent_encoding,Response.iter_content,Response.iter_lines,Response.content,Response.text,Response.json,Response.links,Response.raise_for_status,Response.close,generate",
        "requests/auth.py:_basic_auth_str,AuthBase.__call__,HTTPBasicAuth.__init__,HTTPBasicAuth.__eq__,HTTPBasicAuth.__ne__,HTTPBasicAuth.__call__,HTTPProxyAuth.__call__,HTTPDigestAuth.__init__,HTTPDigestAuth.init_per_thread_state,HTTPDigestAuth.build_digest_header,HTTPDigestAuth.handle_redirect,HTTPDigestAuth.handle_401,HTTPDigestAuth.__call__,HTTPDigestAuth.__eq__,HTTPDigestAuth.__ne__,md5_utf8,sha_utf8,sha256_utf8,sha512_utf8",
        "requests/exceptions.py:RequestException.__init__",
        "requests/hooks.py:default_hooks,dispatch_hook",
        "requests/adapters.py:BaseAdapter.__init__,BaseAdapter.send,BaseAdapter.close,HTTPAdapter.__init__,HTTPAdapter.__getstate__,HTTPAdapter.__setstate__,HTTPAdapter.init_poolmanager,HTTPAdapter.proxy_manager_for,HTTPAdapter.cert_verify,HTTPAdapter.build_response,HTTPAdapter.get_connection,HTTPAdapter.close,HTTPAdapter.request_url,HTTPAdapter.add_headers,HTTPAdapter.proxy_headers,HTTPAdapter.send,SOCKSProxyManager",
        "requests/structures.py:CaseInsensitiveDict.__init__,CaseInsensitiveDict.__setitem__,CaseInsensitiveDict.__getitem__,CaseInsensitiveDict.__delitem__,CaseInsensitiveDict.__iter__,CaseInsensitiveDict.__len__,CaseInsensitiveDict.lower_items,CaseInsensitiveDict.__eq__,CaseInsensitiveDict.copy,CaseInsensitiveDict.__repr__,LookupDict.__init__,LookupDict.__repr__,LookupDict.__getitem__,LookupDict.get",
        "requests/status_codes.py:_init,doc",
        "requests/api.py:request,get,options,head,post,put,patch,delete",
        "requests/help.py:_implementation,info,main",
        "requests/cookies.py:MockRequest.__init__,MockRequest.get_type,MockRequest.get_host,MockRequest.get_origin_req_host,MockRequest.get_full_url,MockRequest.is_unverifiable,MockRequest.has_header,MockRequest.get_header,MockRequest.add_header,MockRequest.add_unredirected_header,MockRequest.get_new_headers,MockRequest.unverifiable,MockRequest.origin_req_host,MockRequest.host,MockResponse.__init__,MockResponse.info,MockResponse.getheaders,extract_cookies_to_jar,get_cookie_header,remove_cookie_by_name,RequestsCookieJar.get,RequestsCookieJar.set,RequestsCookieJar.iterkeys,RequestsCookieJar.keys,RequestsCookieJar.itervalues,RequestsCookieJar.values,RequestsCookieJar.iteritems,RequestsCookieJar.items,RequestsCookieJar.list_domains,RequestsCookieJar.list_paths,RequestsCookieJar.multiple_domains,RequestsCookieJar.get_dict,RequestsCookieJar.__contains__,RequestsCookieJar.__getitem__,RequestsCookieJar.__setitem__,RequestsCookieJar.__delitem__,RequestsCookieJar.set_cookie,RequestsCookieJar.update,RequestsCookieJar._find,RequestsCookieJar._find_no_duplicates,RequestsCookieJar.__getstate__,RequestsCookieJar.__setstate__,RequestsCookieJar.copy,RequestsCookieJar.get_policy,_copy_cookie_jar,create_cookie,morsel_to_cookie,cookiejar_from_dict,merge_cookies",
        "requests/_internal_utils.py:to_native_string,unicode_is_ascii"
    ]
}